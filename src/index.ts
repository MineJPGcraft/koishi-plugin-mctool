import { Context, Schema, Session, h, Logger } from 'koishi';
import { Socket } from 'net';
import { Buffer } from 'buffer';
import {} from '@koishijs/plugin-server'

export const name = 'mctook';

const logger = new Logger(name);

export const inject = ['database', 'server']; // æ³¨å…¥ database å’Œ server æœåŠ¡

const RCON_PACKET_TYPE_AUTH = 3;
const RCON_PACKET_TYPE_COMMAND = 2;
const RCON_PACKET_TYPE_RESPONSE = 0; // Used for AUTH_RESPONSE and RESPONSE_VALUE in the example source

export interface Config {
  host: string;
  port: number;
  password: string;
  verificationTimeout: number;
  //kickOnTimeout: boolean; // This now applies to the timeout *after* initial webhook kick
  commandPrefix: string;
  rconConnectTimeout: number; // Used in sendRconCommand
  rconResponseTimeout: number; // Used in sendRconCommand
  webhookPath: string; // Path to listen for webhooks
  webhookSecret?: string; // Optional secret for webhook validation
  bindChannel?: string; // Optional channel/group ID to instruct users to go to for binding (in kick message)
}


export const Config: Schema<Config> = Schema.object({
  host: Schema.string().required().description('Minecraft æœåŠ¡å™¨ RCON åœ°å€'),
  port: Schema.number().default(25575).description('Minecraft æœåŠ¡å™¨ RCON ç«¯å£'),
  password: Schema.string().role('secret').required().description('RCON å¯†ç '),
  verificationTimeout: Schema.number().default(10 * 60 * 1000).description('éªŒè¯è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰'), // Timeout for the pending verification state
  //kickOnTimeout: Schema.boolean().default(true).description('è¶…æ—¶æ˜¯å¦è¸¢å‡ºç©å®¶ï¼ˆåœ¨éªŒè¯çŠ¶æ€è¶…æ—¶åï¼‰'), // This might be less relevant now?
  commandPrefix: Schema.string().default('mc').description('æ’ä»¶çš„ä¸»æŒ‡ä»¤å'),
  rconConnectTimeout: Schema.number().default(5000).description('RCON è¿æ¥è¶…æ—¶æ—¶é—´ (æ¯«ç§’)'),
  rconResponseTimeout: Schema.number().default(10000).description('RCON å‘½ä»¤å“åº”è¶…æ—¶æ—¶é—´ (æ¯«ç§’)'),
  webhookPath: Schema.string().default('/mc-webhook').description('Minecraft æœåŠ¡å™¨å‘é€ webhook çš„è·¯å¾„'),
  webhookSecret: Schema.string().role('secret').description('å¯é€‰ï¼ŒWebhook å®‰å…¨å¯†é’¥ã€‚å¦‚æœè®¾ç½®ï¼Œè¯·é…ç½®æœåŠ¡å™¨åœ¨è¯·æ±‚å¤´ä¸­å¸¦ä¸Š "X-Secret" æˆ–ä½œä¸ºæŸ¥è¯¢å‚æ•°å‘é€ã€‚'),
  bindChannel: Schema.string().description('å¯é€‰ï¼Œå‘ŠçŸ¥ç©å®¶è¿›è¡Œç»‘å®šçš„ Koishi é¢‘é“/ç¾¤èŠ IDã€‚'),
});

declare module 'koishi' {
  interface Tables {
    minecraft_bindings: MinecraftBinding;
  }
}

export interface MinecraftBinding {
  id: number;
  platform: string; // Platform where the user initiated binding (*after* webhook kick)
  koishiUserId: string; // Koishi user ID who completed the binding
  mcUsername: string;
  bindTimestamp: Date;
}

// Stores state for players kicked by webhook, waiting for verification code submission via Koishi
interface PendingVerification {
  mcUsername: string;
  verificationCode: string; // Required once generated by webhook handler
  timeoutTimer: NodeJS.Timeout;
  timestamp: number;
  // Note: koishiUserId, platform, botSelfId are NOT known at this stage.
  // They are captured when the user issues the `mc.code` command.
}

function createRconPacket(type: number, body: string): Buffer { // Removed ID parameter as example uses hardcoded 0
    const bodyBuffer = Buffer.from(body, 'utf8');
    // Example's length calculation: body.length + 10
    // RCON spec: Length = ID(4) + TYPE(4) + PAYLOAD(n) + 2 null terminators
    // Example's buffer alloc: length + 4
    // Example's writeInt16LE(0, length + 2) implies 2 nulls, total size length+4 covers this.
    // Let's stick to the example's length=body.length+10 and buffer.alloc(length+4)
    const length = Buffer.byteLength(body, 'utf8') + 10; // Follow example's length calculation
    const buffer = Buffer.alloc(length + 4); // Follow example's total buffer size
  
    buffer.writeInt32LE(length, 0); // Write Length field
    buffer.writeInt32LE(0, 4); // Request ID (hardcoded 0 in example)
    buffer.writeInt32LE(type, 8); // Type
    buffer.write(body, 12, 'utf8'); // Payload
    buffer.writeInt16LE(0, length + 2); // Two null terminators
  
    return buffer;
  }
  export async function sendRconCommand(config: Config, command: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const socket = new Socket()
      let authenticated = false
      let responseBuffer = ''
      let expectedLength = 0
  
      socket.connect(config.port, config.host, () => {
        // å‘é€è®¤è¯åŒ…
        const authPacket = createRconPacket(RCON_PACKET_TYPE_AUTH, config.password)
        socket.write(authPacket)
      })
  
      socket.on('data', (data) => {
        try {
          const packetLength = data.readInt32LE(0)
          const packetType = data.readInt32LE(4)
  
          if (packetType === RCON_PACKET_TYPE_RESPONSE) {
            if (!authenticated) {
              // è®¤è¯æˆåŠŸ
              authenticated = true
              // å‘é€å‘½ä»¤åŒ…
              const commandPacket = createRconPacket(RCON_PACKET_TYPE_COMMAND, command)
              socket.write(commandPacket)
            } else {
              // æ£€æŸ¥ offset æ˜¯å¦åˆæ³•
              const offset = 12 // RCON æ•°æ®åŒ…ä½“çš„èµ·å§‹ä½ç½®
              if (offset < 0 || offset >= data.length) {
                throw new RangeError(`Invalid offset: ${offset}`)
              }
  
              // è¯»å–å“åº”æ•°æ®
              const responseData = data.toString('utf8', offset, packetLength + 4)
              responseBuffer += responseData
  
              // æ£€æŸ¥æ˜¯å¦æ”¶åˆ°å®Œæ•´å“åº”
              if (responseBuffer.length >= expectedLength) {
                resolve(responseBuffer)
                socket.destroy()
              }
            }
          } else if (packetType === RCON_PACKET_TYPE_AUTH && data.readInt32LE(8) === -1) {
            // è®¤è¯å¤±è´¥
            reject('RCON è®¤è¯å¤±è´¥ï¼šå¯†ç é”™è¯¯')
            socket.destroy()
          }
        } catch (error) {
          reject(`RCON æ•°æ®åŒ…è§£æé”™è¯¯ï¼š${error.message}`)
          socket.destroy()
        }
      })
  
      socket.on('end', () => {
        resolve(responseBuffer)
      })
  
      socket.on('error', (err) => {
        reject(`RCON è¿æ¥é”™è¯¯ï¼š${err.message}`)
      })
    })
  }

export function apply(ctx: Context, config: Config) {
  const mainCommand = config.commandPrefix || 'mc';

  ctx.model.extend('minecraft_bindings', {
    id: 'unsigned',
    platform: 'string',
    koishiUserId: 'string',
    mcUsername: 'string',
    bindTimestamp: 'timestamp',
  }, {
    primary: 'id',
    autoInc: true,
    unique: [
      ['platform', 'koishiUserId'],
      ['mcUsername'],
    ]
  });

  // pendingVerifications map stores MC username -> PendingVerification state
  const pendingVerifications = new Map<string, PendingVerification>();

  function clearPending(mcUsername: string) {
    const pending = pendingVerifications.get(mcUsername);
    if (pending) {
      clearTimeout(pending.timeoutTimer);
      pendingVerifications.delete(mcUsername);
      logger.info(`[Pending] Cleared pending verification for MC user: ${mcUsername}`);
    }
  }

  // === Webhook Listener ===
  ctx.server.post(config.webhookPath, async (c) => {
      // Validate webhook secret if configured
      if (config.webhookSecret) {
          const secret = c.request.headers['x-secret'] || c.request.query.secret;
          if (secret !== config.webhookSecret) {
              logger.warn(`[Webhook] Received request with invalid secret from ${c.request.ip}`);
              c.response.status = 401; // Unauthorized
              return 'Invalid secret';
          }
      }

      // Parse request body as JSON
      let payload;
      try {
          payload = c.request.body;
          if (typeof payload !== 'object') {
               throw new Error('Invalid JSON body');
          }
      } catch (error: any) {
          logger.warn(`[Webhook] Failed to parse JSON body from ${c.request.ip}: ${error.message}`);
          c.response.status = 400; // Bad Request
          return 'Invalid JSON body';
      }

      // Check if it's a player login event
      if (payload.event_type === 'login' && payload.player_name) {
          const mcUsername = payload.player_name;
          logger.info(`[Webhook] Received login event for player: ${mcUsername}`);

          try {
              // 1. Check if already bound
              const existingBinding = await ctx.database.get('minecraft_bindings', { mcUsername });
              if (existingBinding.length > 0) {
                  logger.info(`[Webhook] Player ${mcUsername} is already bound (Koishi user: ${existingBinding[0].platform}:${existingBinding[0].koishiUserId}). Doing nothing.`);
                  c.response.status = 200; // OK
                  return 'Already bound';
              }
              /*
              // 2. Check if already in pending state
              if (pendingVerifications.has(mcUsername)) {
                  logger.info(`[Webhook] Player ${mcUsername} is already in pending state. Doing nothing (assuming previous kick is sufficient).`);
                   c.response.status = 200; // OK
                   return 'Already pending verification';
              }*/

              // 3. If not bound and not pending, start verification
              const verificationCode = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit code
              logger.info(`[Webhook] Starting verification for ${mcUsername}. Code: ${verificationCode}`);

              // Kick player with verification instructions
              let kickMessage = `ä½ çš„éªŒè¯ç æ˜¯: ${verificationCode}. è¯·å¯¹æœºå™¨äººè¾“å…¥ "${mainCommand}.code ${verificationCode}" æ¥ç»‘å®šä½ çš„è´¦å·ã€‚`;
              if (config.bindChannel) {
                  // If a specific binding channel is configured, instruct the user to go there
                  kickMessage = `ä½ çš„éªŒè¯ç æ˜¯: ${verificationCode}. åœ¨QQç¾¤ ${config.bindChannel} æˆ–ç§èŠæœºå™¨äººè¾“å…¥ "${mainCommand}.code ${verificationCode}" æ¥ç»‘å®šä½ çš„è´¦å·ã€‚`;
              }
              const kickCommand = `kick ${mcUsername} ${kickMessage}`;

              try {
                  const kickResponse = await sendRconCommand(config, kickCommand);
                  logger.info(`[Webhook] Kicked player ${mcUsername} with verification code. RCON Response: ${kickResponse}`);

                   // Store pending state with timeout
                  const timeoutTimer = setTimeout(async () => {
                      // Timeout logic: remove pending state and potentially remove whitelist (if added on kick)
                      const pending = pendingVerifications.get(mcUsername);
                       if (pending && pending.verificationCode === verificationCode) { // Check if it's still the same pending state
                         logger.warn(`[Pending] Verification timed out for MC user: ${mcUsername}`);
                         pendingVerifications.delete(mcUsername); // Remove from pending map

                         // Optional: If you add whitelist *on kick* and remove it on timeout, do it here.
                         // Based on the flow (kick -> verify -> whitelist), no whitelist removal needed here.

                         // Optional: Kick again if needed (less likely useful)
                         // if (config.kickOnTimeout) { ... }
                       } else {
                          logger.debug(`[Pending] Timeout triggered for ${mcUsername} but pending state changed or cleared.`);
                       }

                  }, config.verificationTimeout);

                  pendingVerifications.set(mcUsername, {
                      mcUsername,
                      verificationCode,
                      timeoutTimer,
                      timestamp: Date.now(),
                  });

                  c.response.status = 200; // OK
                  return 'Verification process initiated';

              } catch (rconError: any) {
                  logger.error(`[Webhook] Failed to kick player ${mcUsername} via RCON:`, rconError.message);
                  // Player couldn't be kicked, binding cannot proceed via this webhook trigger
                  c.response.status = 500; // Internal Server Error
                  return 'Failed to kick player via RCON';
              }

          } catch (dbError: any) {
              logger.error(`[Webhook] Database error while processing login for ${mcUsername}:`, dbError);
              c.response.status = 500; // Internal Server Error
              return 'Database error';
          }

      } else {
          logger.debug(`[Webhook] Received non-login event or missing data from ${c.request.ip}. Event type: ${payload.event_type}, Player: ${payload.player_name}`);
          c.response.status = 200; // OK (ignore non-login events)
          return 'Not a login event';
      }
  });

  // === Command Definitions ===
  const cmd = ctx.command(mainCommand, 'Minecraft ç»‘å®šç›¸å…³æŒ‡ä»¤');

  // mc.bind and mc.verify commands are REMOVED in this webhook-triggered flow.

  cmd.subcommand('.code <code:string>', 'æäº¤æ¸¸æˆå†…æ”¶åˆ°çš„éªŒè¯ç ', { checkArgCount: true })
     .usage(`è¯·æä¾›ä½ åœ¨æ¸¸æˆå†…æ”¶åˆ°çš„6ä½æ•°å­—éªŒè¯ç ã€‚ä¾‹å¦‚ï¼š${mainCommand}.code 123456`)
    .action(async ({ session }, code) => {
        if (!session?.userId || !session?.platform || !session?.bot?.selfId) {
             // Should not happen with normal sessions, but safety check
            return 'æ— æ³•è·å–æ‚¨çš„ç”¨æˆ·ä¿¡æ¯ï¼Œè¯·ç¨åå†è¯•ã€‚';
        }

        if (!/^\d{6}$/.test(code)) {
            return 'éªŒè¯ç æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º 6 ä½æ•°å­—ã€‚';
        }

        let pending = undefined as PendingVerification | undefined;
        let mcUsername = undefined as string | undefined;
        let pendingKeyToDelete = undefined as string | undefined; // mcUsername is the key now

        // Find the pending verification entry by CODE
        // Iterate through the pendingVerifications map to find a match
        for (const [userKey, pendingEntry] of pendingVerifications.entries()) {
             if (pendingEntry.verificationCode === code) {
                 pending = pendingEntry;
                 mcUsername = pendingEntry.mcUsername;
                 pendingKeyToDelete = userKey; // Found the key (mcUsername)
                 break; // Found the matching code
             }
        }

        if (!pending || !mcUsername) {
             // No pending entry found for this code
             logger.warn(`[CodeCmd] Incorrect or expired verification code submitted by ${session.platform}:${session.userId}. Code: ${code}`);
            return 'éªŒè¯ç é”™è¯¯æˆ–å·²è¿‡æœŸï¼Œè¯·æ£€æŸ¥åé‡è¯•æˆ–é‡æ–°è¿›å…¥æœåŠ¡å™¨è·å–æ–°çš„éªŒè¯ç ã€‚';
        }

        // === Code matched pending entry, proceed to binding ===
        logger.info(`[CodeCmd] Verification code matched for MC user: ${mcUsername}. User submitting: ${session.platform}:${session.userId}`);

        // Clear the pending state immediately upon successful code match
        clearPending(mcUsername); // Use the key (mcUsername) to delete

        try {
            // 1. Check if the Koishi user is already bound
            const existingBindingByUser = await ctx.database.get('minecraft_bindings', { platform: session.platform, koishiUserId: session.userId });
            if (existingBindingByUser.length > 0) {
                 // This Koishi user is already bound to another MC account
                 logger.warn(`[CodeCmd] Koishi user ${session.platform}:${session.userId} is already bound to ${existingBindingByUser[0].mcUsername}.`);
                 // Re-add the pending state temporarily? No, just inform the user.
                 return `æ‚¨çš„QQè´¦å·å·²ç»ç»‘å®šäº† Minecraft è´¦å·: ${existingBindingByUser[0].mcUsername}ã€‚å¦‚éœ€è§£ç»‘è¯·è”ç³»ç®¡ç†å‘˜ã€‚`;
            }

            // 2. Check if the MC username has been bound by another Koishi user in the meantime
             const existingBindingByMc = await ctx.database.get('minecraft_bindings', { mcUsername });
             if (existingBindingByMc.length > 0) {
                 // This MC account was bound by someone else while the user was entering the code
                 logger.warn(`[CodeCmd] MC user ${mcUsername} was bound by ${existingBindingByMc[0].platform}:${existingBindingByMc[0].koishiUserId}.`);
                 return `Minecraft è´¦å· ${mcUsername} åœ¨æ‚¨è¾“å…¥éªŒè¯ç æœŸé—´å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®šã€‚è¯·è”ç³»ç®¡ç†å‘˜ç¡®è®¤ã€‚`;
             }

            // 3. If checks pass, save the binding
            await ctx.database.create('minecraft_bindings', {
                platform: session.platform,
                koishiUserId: session.userId,
                mcUsername: mcUsername,
                bindTimestamp: new Date(),
            });

            logger.success(`[CodeCmd] Binding saved: ${session.platform}:${session.userId} <-> ${mcUsername}`);

            // 4. Add player to whitelist (they were likely removed when kicked or aren't added until verified)
            const whitelistAddCmd = `whitelist add ${mcUsername}`;
             try {
                 const whitelistAddResp = await sendRconCommand(config, whitelistAddCmd);
                 logger.info(`[CodeCmd] Added ${mcUsername} to whitelist after successful binding. Response: ${whitelistAddResp}`);
                 // Optional: Check if whitelistAddResp indicates success
             } catch (rconError: any) {
                 logger.error(`[CodeCmd] Failed to add ${mcUsername} to whitelist after successful binding:`, rconError.message);
                 // Binding is saved, but whitelist failed - inform user/admin
                 await session.send(`æ³¨æ„ï¼šæˆåŠŸç»‘å®šè´¦å· (${mcUsername})ï¼Œä½†æ·»åŠ ç™½åå•å¤±è´¥ (${rconError.message})ã€‚è¯·è”ç³»ç®¡ç†å‘˜æ‰‹åŠ¨æ·»åŠ ç™½åå•ã€‚`);
                 return; // Exit action, avoid sending success message below
             }

            // 5. Send success message
            return `ğŸ‰ ç»‘å®šæˆåŠŸï¼æ‚¨çš„QQè´¦å· (${session.username}) ç°å·²ç»‘å®šåˆ° Minecraft è´¦å·: ${mcUsername}ã€‚ç°åœ¨å¯ä»¥è¿›å…¥æœåŠ¡å™¨äº†ã€‚`;

        } catch (dbError: any) {
            logger.error(`[CodeCmd] Database error while saving binding for ${session.platform}:${session.userId}:`, dbError);

             if (dbError.code === 'ER_DUP_ENTRY' || (dbError.message && dbError.message.includes('UNIQUE constraint failed'))) {
                  // This case should theoretically be caught by the checks above, but handling as fallback
                 const existing = await ctx.database.get('minecraft_bindings', { $or: [ { platform: session.platform, koishiUserId: session.userId }, { mcUsername: mcUsername } ]});
                 if(existing.length > 0) {
                     const conflict = existing[0];
                     if (conflict.mcUsername === mcUsername) {
                          return `ç»‘å®šå¤±è´¥ï¼šMinecraft è´¦å· ${mcUsername} åœ¨æ‚¨éªŒè¯æœŸé—´å·²è¢«ç»‘å®šã€‚è¯·è”ç³»ç®¡ç†å‘˜å¤„ç†ã€‚`;
                     } else {
                         return `ç»‘å®šå¤±è´¥ï¼šæ‚¨çš„ Koishi è´¦å·ä¼¼ä¹å·²ç»‘å®šäº†å…¶ä»– MC è´¦å· (${conflict.mcUsername})ã€‚`;
                     }
                 } else {
                     // If DB error indicates duplicate but we couldn't find the record, something is wrong.
                     return 'ç»‘å®šå¤±è´¥ï¼šå†™å…¥æ•°æ®åº“æ—¶å‘ç”Ÿå”¯ä¸€æ€§çº¦æŸé”™è¯¯ï¼Œä½†æœªèƒ½å®šä½å†²çªè®°å½•ã€‚è¯·è”ç³»ç®¡ç†å‘˜ã€‚';
                 }
             }
             // For other database errors
            return 'ç»‘å®šè¿‡ç¨‹ä¸­å‘ç”Ÿæ•°æ®åº“é”™è¯¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ã€‚';
        }
    });

    // Middleware for private message verification (check if it's a 6-digit code)
    // If a 6-digit code is received in private message, simulate the `.code` command action.
      ctx.middleware(async (session, next) => {
        if (session.isDirect && /^\d{6}$/.test(session.content ?? '')) {
            const code = session.content!;
            logger.debug(`[Middleware] Received potential verification code via DM: ${code}`);

            // Find the pending verification entry by CODE
            let pending = undefined as PendingVerification | undefined;
            let mcUsername = undefined as string | undefined;

            for (const [userKey, pendingEntry] of pendingVerifications.entries()) {
                 if (pendingEntry.verificationCode === code) {
                     pending = pendingEntry;
                     mcUsername = pendingEntry.mcUsername;
                     break;
                 }
            }

            if (!pending || !mcUsername) {
                // No matching pending verification, proceed to next middleware
                 // logger.debug(`[Middleware] No pending verification found for code ${code}.`);
                return next();
            }

             // === Code matched pending entry, proceed to binding (similar to .code action) ===
             // Clear pending state immediately
             clearPending(mcUsername);

            logger.info(`[Middleware] Verification code matched for MC user: ${mcUsername} via DM from ${session.platform}:${session.userId}.`);

            try {
                const existingBindingByUser = await ctx.database.get('minecraft_bindings', { platform: session.platform, koishiUserId: session.userId });
                if (existingBindingByUser.length > 0) {
                     logger.warn(`[Middleware] Koishi user ${session.platform}:${session.userId} is already bound to ${existingBindingByUser[0].mcUsername}. (Via DM)`);
                     await session.send(`æ‚¨çš„ Koishi è´¦å·å·²ç»ç»‘å®šäº† Minecraft è´¦å·: ${existingBindingByUser[0].mcUsername}ã€‚å¦‚éœ€è§£ç»‘è¯·è”ç³»ç®¡ç†å‘˜ã€‚`);
                     return; // Message handled
                }

                 const existingBindingByMc = await ctx.database.get('minecraft_bindings', { mcUsername });
                 if (existingBindingByMc.length > 0) {
                     logger.warn(`[Middleware] MC user ${mcUsername} was bound by ${existingBindingByMc[0].platform}:${existingBindingByMc[0].koishiUserId}. (Via DM)`);
                     await session.send(`Minecraft è´¦å· ${mcUsername}åœ¨æ‚¨è¾“å…¥éªŒè¯ç æœŸé—´å·²è¢«å…¶ä»–ç”¨æˆ·ç»‘å®šã€‚è¯·è”ç³»ç®¡ç†å‘˜ç¡®è®¤ã€‚`);
                     return; // Message handled
                 }

                await ctx.database.create('minecraft_bindings', {
                    platform: session.platform,
                    koishiUserId: session.userId,
                    mcUsername: mcUsername,
                    bindTimestamp: new Date(),
                });

                logger.success(`[Middleware] Binding saved (DM): ${session.platform}:${session.userId} <-> ${mcUsername}`);

                const whitelistAddCmd = `whitelist add ${mcUsername}`;
                 try {
                     const whitelistAddResp = await sendRconCommand(config, whitelistAddCmd);
                     logger.info(`[Middleware] Added ${mcUsername} to whitelist after successful binding (DM). Response: ${whitelistAddResp}`);
                 } catch (rconError: any) {
                     logger.error(`[Middleware] Failed to add ${mcUsername} to whitelist after successful binding (DM):`, rconError.message);
                     await session.send(`æ³¨æ„ï¼šæˆåŠŸç»‘å®šè´¦å· (${mcUsername})ï¼Œä½†æ·»åŠ ç™½åå•å¤±è´¥ (${rconError.message})ã€‚è¯·è”ç³»ç®¡ç†å‘˜æ‰‹åŠ¨æ·»åŠ ç™½åå•ã€‚`);
                      return; // Message handled
                 }

                await session.send(`ğŸ‰ ç»‘å®šæˆåŠŸï¼æ‚¨çš„ Koishi è´¦å· (${session.username}) ç°å·²ç»‘å®šåˆ° Minecraft è´¦å·: ${mcUsername}ã€‚ç™½åå•å·²æ·»åŠ ï¼Œç°åœ¨å¯ä»¥è¿›å…¥æœåŠ¡å™¨äº†ã€‚`);
                return; // Message handled

            } catch (dbError: any) {
                logger.error(`[Middleware] Database error saving binding for ${session.platform}:${session.userId} (DM):`, dbError);
                 if (dbError.code === 'ER_DUP_ENTRY' || (dbError.message && dbError.message.includes('UNIQUE constraint failed'))) {
                      const existing = await ctx.database.get('minecraft_bindings', { $or: [ { platform: session.platform, koishiUserId: session.userId }, { mcUsername: mcUsername } ]});
                       if(existing.length > 0) {
                            const conflict = existing[0];
                            if (conflict.mcUsername === mcUsername) {
                                 await session.send(`ç»‘å®šå¤±è´¥ï¼šMinecraft è´¦å· ${conflict.mcUsername} åœ¨æ‚¨éªŒè¯æœŸé—´å·²è¢«ç»‘å®šã€‚è¯·è”ç³»ç®¡ç†å‘˜å¤„ç†ã€‚`);
                            } else {
                                await session.send(`ç»‘å®šå¤±è´¥ï¼šæ‚¨çš„ Koishi è´¦å·ä¼¼ä¹å·²ç»‘å®šäº†å…¶ä»– MC è´¦å· (${conflict.mcUsername})ã€‚`);
                            }
                         } else {
                              await session.send('ç»‘å®šå¤±è´¥ï¼šå†™å…¥æ•°æ®åº“æ—¶å‘ç”Ÿå”¯ä¸€æ€§çº¦æŸé”™è¯¯ï¼Œä½†æœªèƒ½å®šä½å†²çªè®°å½•ã€‚è¯·è”ç³»ç®¡ç†å‘˜ã€‚');
                         }
                    return; // Message handled
                 }
                await session.send('ç»‘å®šè¿‡ç¨‹ä¸­å‘ç”Ÿæ•°æ®åº“é”™è¯¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ã€‚');
                return; // Message handled
            }
        }
        // If not a 6-digit private message from a pending user, pass to next middleware
        return next();
    });

     cmd.subcommand('.info', 'æŸ¥çœ‹æ‚¨ç»‘å®šçš„ Minecraft è´¦å·')
        .action(async ({ session }) => {
            if (!session?.userId || !session?.platform) {
                return 'æ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯ã€‚';
            }
            const binding = await ctx.database.get('minecraft_bindings', { platform: session.platform, koishiUserId: session.userId });
            if (binding.length > 0) {
                return `æ‚¨ (${session.username}) å·²ç»‘å®š Minecraft è´¦å·: ${binding[0].mcUsername}`;
            } else {
                return `æ‚¨å°šæœªç»‘å®š Minecraft è´¦å·ã€‚è¯·é€šè¿‡è¿›å…¥ Minecraft æœåŠ¡å™¨è§¦å‘ç»‘å®šæµç¨‹ï¼Œç„¶ååœ¨ Koishi ä¸­ä½¿ç”¨ \`${mainCommand}.code <éªŒè¯ç >\` å®Œæˆç»‘å®šã€‚`;
            }
        });

    // Admin unbind command
    ctx.command(`${mainCommand}.unbind <mcUsername:string>`, 'ç®¡ç†å‘˜è§£é™¤ç»‘å®š Minecraft è´¦å·', { authority: 3 })
        .action(async ({ session }, mcUsername) => {
             if (!mcUsername) {
                 return 'è¯·æä¾›è¦è§£é™¤ç»‘å®šçš„ Minecraft ç”¨æˆ·åã€‚'
             }
             try {
                const result = await ctx.database.remove('minecraft_bindings', { mcUsername });
                // Check for deletedCount
                if (result && typeof result === 'object' && 'deletedCount' in result && (result as any).deletedCount > 0) {
                     logger.info(`[Admin] Removed binding for MC user: ${mcUsername}. (${(result as any).deletedCount} entries)`);
                    // Attempt to remove whitelist (optional, best effort, new connection)
                    try {
                        // Use the config directly as session is not needed for RCON call here
                        const whitelistResponse = await sendRconCommand(config, `whitelist remove ${mcUsername}`);
                         logger.info(`[Admin] Attempted to remove whitelist for ${mcUsername} after unbinding. Response: ${whitelistResponse}`);
                    } catch (rconErr: any) {
                        logger.warn(`[Admin] Failed to remove whitelist for ${mcUsername} after unbinding:`, rconErr.message);
                    }
                    return `å·²è§£é™¤ Minecraft è´¦å· ${mcUsername} çš„ç»‘å®šã€‚`;
                } else {
                    return `æœªæ‰¾åˆ°ä¸ Minecraft è´¦å· ${mcUsername} å…³è”çš„ç»‘å®šè®°å½•ã€‚`;
                }
             } catch (dbError: any) {
                 logger.error(`[Admin] Database error during unbind for ${mcUsername}:`, dbError);
                 return 'è§£é™¤ç»‘å®šæ—¶å‘ç”Ÿæ•°æ®åº“é”™è¯¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ã€‚';
             }
        });
}