import { Context, Schema, Session, h, Logger } from 'koishi';
import { Socket } from 'net';
import { Buffer } from 'buffer';
import {} from '@koishijs/plugin-server'

export const name = 'mctook';

const logger = new Logger(name);

export const inject = ['database', 'server']; // 注入 database 和 server 服务

const RCON_PACKET_TYPE_AUTH = 3;
const RCON_PACKET_TYPE_COMMAND = 2;
const RCON_PACKET_TYPE_RESPONSE = 0; // Used for AUTH_RESPONSE and RESPONSE_VALUE in the example source

export interface Config {
  host: string;
  port: number;
  password: string;
  verificationTimeout: number;
  //kickOnTimeout: boolean; // This now applies to the timeout *after* initial webhook kick
  commandPrefix: string;
  rconConnectTimeout: number; // Used in sendRconCommand
  rconResponseTimeout: number; // Used in sendRconCommand
  webhookPath: string; // Path to listen for webhooks
  webhookSecret?: string; // Optional secret for webhook validation
  bindChannel?: string; // Optional channel/group ID to instruct users to go to for binding (in kick message)
}


export const Config: Schema<Config> = Schema.object({
  host: Schema.string().required().description('Minecraft 服务器 RCON 地址'),
  port: Schema.number().default(25575).description('Minecraft 服务器 RCON 端口'),
  password: Schema.string().role('secret').required().description('RCON 密码'),
  verificationTimeout: Schema.number().default(10 * 60 * 1000).description('验证超时时间（毫秒）'), // Timeout for the pending verification state
  //kickOnTimeout: Schema.boolean().default(true).description('超时是否踢出玩家（在验证状态超时后）'), // This might be less relevant now?
  commandPrefix: Schema.string().default('mc').description('插件的主指令名'),
  rconConnectTimeout: Schema.number().default(5000).description('RCON 连接超时时间 (毫秒)'),
  rconResponseTimeout: Schema.number().default(10000).description('RCON 命令响应超时时间 (毫秒)'),
  webhookPath: Schema.string().default('/mc-webhook').description('Minecraft 服务器发送 webhook 的路径'),
  webhookSecret: Schema.string().role('secret').description('可选，Webhook 安全密钥。如果设置，请配置服务器在请求头中带上 "X-Secret" 或作为查询参数发送。'),
  bindChannel: Schema.string().description('可选，告知玩家进行绑定的 Koishi 频道/群聊 ID。'),
});

declare module 'koishi' {
  interface Tables {
    minecraft_bindings: MinecraftBinding;
  }
}

export interface MinecraftBinding {
  id: number;
  platform: string; // Platform where the user initiated binding (*after* webhook kick)
  koishiUserId: string; // Koishi user ID who completed the binding
  mcUsername: string;
  bindTimestamp: Date;
}

// Stores state for players kicked by webhook, waiting for verification code submission via Koishi
interface PendingVerification {
  mcUsername: string;
  verificationCode: string; // Required once generated by webhook handler
  timeoutTimer: NodeJS.Timeout;
  timestamp: number;
  // Note: koishiUserId, platform, botSelfId are NOT known at this stage.
  // They are captured when the user issues the `mc.code` command.
}

function createRconPacket(type: number, body: string): Buffer { // Removed ID parameter as example uses hardcoded 0
    const bodyBuffer = Buffer.from(body, 'utf8');
    // Example's length calculation: body.length + 10
    // RCON spec: Length = ID(4) + TYPE(4) + PAYLOAD(n) + 2 null terminators
    // Example's buffer alloc: length + 4
    // Example's writeInt16LE(0, length + 2) implies 2 nulls, total size length+4 covers this.
    // Let's stick to the example's length=body.length+10 and buffer.alloc(length+4)
    const length = Buffer.byteLength(body, 'utf8') + 10; // Follow example's length calculation
    const buffer = Buffer.alloc(length + 4); // Follow example's total buffer size
  
    buffer.writeInt32LE(length, 0); // Write Length field
    buffer.writeInt32LE(0, 4); // Request ID (hardcoded 0 in example)
    buffer.writeInt32LE(type, 8); // Type
    buffer.write(body, 12, 'utf8'); // Payload
    buffer.writeInt16LE(0, length + 2); // Two null terminators
  
    return buffer;
  }
  export async function sendRconCommand(config: Config, command: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const socket = new Socket()
      let authenticated = false
      let responseBuffer = ''
      let expectedLength = 0
  
      socket.connect(config.port, config.host, () => {
        // 发送认证包
        const authPacket = createRconPacket(RCON_PACKET_TYPE_AUTH, config.password)
        socket.write(authPacket)
      })
  
      socket.on('data', (data) => {
        try {
          const packetLength = data.readInt32LE(0)
          const packetType = data.readInt32LE(4)
  
          if (packetType === RCON_PACKET_TYPE_RESPONSE) {
            if (!authenticated) {
              // 认证成功
              authenticated = true
              // 发送命令包
              const commandPacket = createRconPacket(RCON_PACKET_TYPE_COMMAND, command)
              socket.write(commandPacket)
            } else {
              // 检查 offset 是否合法
              const offset = 12 // RCON 数据包体的起始位置
              if (offset < 0 || offset >= data.length) {
                throw new RangeError(`Invalid offset: ${offset}`)
              }
  
              // 读取响应数据
              const responseData = data.toString('utf8', offset, packetLength + 4)
              responseBuffer += responseData
  
              // 检查是否收到完整响应
              if (responseBuffer.length >= expectedLength) {
                resolve(responseBuffer)
                socket.destroy()
              }
            }
          } else if (packetType === RCON_PACKET_TYPE_AUTH && data.readInt32LE(8) === -1) {
            // 认证失败
            reject('RCON 认证失败：密码错误')
            socket.destroy()
          }
        } catch (error) {
          reject(`RCON 数据包解析错误：${error.message}`)
          socket.destroy()
        }
      })
  
      socket.on('end', () => {
        resolve(responseBuffer)
      })
  
      socket.on('error', (err) => {
        reject(`RCON 连接错误：${err.message}`)
      })
    })
  }

export function apply(ctx: Context, config: Config) {
  const mainCommand = config.commandPrefix || 'mc';

  ctx.model.extend('minecraft_bindings', {
    id: 'unsigned',
    platform: 'string',
    koishiUserId: 'string',
    mcUsername: 'string',
    bindTimestamp: 'timestamp',
  }, {
    primary: 'id',
    autoInc: true,
    unique: [
      ['platform', 'koishiUserId'],
      ['mcUsername'],
    ]
  });

  // pendingVerifications map stores MC username -> PendingVerification state
  const pendingVerifications = new Map<string, PendingVerification>();

  function clearPending(mcUsername: string) {
    const pending = pendingVerifications.get(mcUsername);
    if (pending) {
      clearTimeout(pending.timeoutTimer);
      pendingVerifications.delete(mcUsername);
      logger.info(`[Pending] Cleared pending verification for MC user: ${mcUsername}`);
    }
  }

  // === Webhook Listener ===
  ctx.server.post(config.webhookPath, async (c) => {
      // Validate webhook secret if configured
      if (config.webhookSecret) {
          const secret = c.request.headers['x-secret'] || c.request.query.secret;
          if (secret !== config.webhookSecret) {
              logger.warn(`[Webhook] Received request with invalid secret from ${c.request.ip}`);
              c.response.status = 401; // Unauthorized
              return 'Invalid secret';
          }
      }

      // Parse request body as JSON
      let payload;
      try {
          payload = c.request.body;
          if (typeof payload !== 'object') {
               throw new Error('Invalid JSON body');
          }
      } catch (error: any) {
          logger.warn(`[Webhook] Failed to parse JSON body from ${c.request.ip}: ${error.message}`);
          c.response.status = 400; // Bad Request
          return 'Invalid JSON body';
      }

      // Check if it's a player login event
      if (payload.event_type === 'login' && payload.player_name) {
          const mcUsername = payload.player_name;
          logger.info(`[Webhook] Received login event for player: ${mcUsername}`);

          try {
              // 1. Check if already bound
              const existingBinding = await ctx.database.get('minecraft_bindings', { mcUsername });
              if (existingBinding.length > 0) {
                  logger.info(`[Webhook] Player ${mcUsername} is already bound (Koishi user: ${existingBinding[0].platform}:${existingBinding[0].koishiUserId}). Doing nothing.`);
                  c.response.status = 200; // OK
                  return 'Already bound';
              }
              /*
              // 2. Check if already in pending state
              if (pendingVerifications.has(mcUsername)) {
                  logger.info(`[Webhook] Player ${mcUsername} is already in pending state. Doing nothing (assuming previous kick is sufficient).`);
                   c.response.status = 200; // OK
                   return 'Already pending verification';
              }*/

              // 3. If not bound and not pending, start verification
              const verificationCode = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit code
              logger.info(`[Webhook] Starting verification for ${mcUsername}. Code: ${verificationCode}`);

              // Kick player with verification instructions
              let kickMessage = `你的验证码是: ${verificationCode}. 请对机器人输入 "${mainCommand}.code ${verificationCode}" 来绑定你的账号。`;
              if (config.bindChannel) {
                  // If a specific binding channel is configured, instruct the user to go there
                  kickMessage = `你的验证码是: ${verificationCode}. 在QQ群 ${config.bindChannel} 或私聊机器人输入 "${mainCommand}.code ${verificationCode}" 来绑定你的账号。`;
              }
              const kickCommand = `kick ${mcUsername} ${kickMessage}`;

              try {
                  const kickResponse = await sendRconCommand(config, kickCommand);
                  logger.info(`[Webhook] Kicked player ${mcUsername} with verification code. RCON Response: ${kickResponse}`);

                   // Store pending state with timeout
                  const timeoutTimer = setTimeout(async () => {
                      // Timeout logic: remove pending state and potentially remove whitelist (if added on kick)
                      const pending = pendingVerifications.get(mcUsername);
                       if (pending && pending.verificationCode === verificationCode) { // Check if it's still the same pending state
                         logger.warn(`[Pending] Verification timed out for MC user: ${mcUsername}`);
                         pendingVerifications.delete(mcUsername); // Remove from pending map

                         // Optional: If you add whitelist *on kick* and remove it on timeout, do it here.
                         // Based on the flow (kick -> verify -> whitelist), no whitelist removal needed here.

                         // Optional: Kick again if needed (less likely useful)
                         // if (config.kickOnTimeout) { ... }
                       } else {
                          logger.debug(`[Pending] Timeout triggered for ${mcUsername} but pending state changed or cleared.`);
                       }

                  }, config.verificationTimeout);

                  pendingVerifications.set(mcUsername, {
                      mcUsername,
                      verificationCode,
                      timeoutTimer,
                      timestamp: Date.now(),
                  });

                  c.response.status = 200; // OK
                  return 'Verification process initiated';

              } catch (rconError: any) {
                  logger.error(`[Webhook] Failed to kick player ${mcUsername} via RCON:`, rconError.message);
                  // Player couldn't be kicked, binding cannot proceed via this webhook trigger
                  c.response.status = 500; // Internal Server Error
                  return 'Failed to kick player via RCON';
              }

          } catch (dbError: any) {
              logger.error(`[Webhook] Database error while processing login for ${mcUsername}:`, dbError);
              c.response.status = 500; // Internal Server Error
              return 'Database error';
          }

      } else {
          logger.debug(`[Webhook] Received non-login event or missing data from ${c.request.ip}. Event type: ${payload.event_type}, Player: ${payload.player_name}`);
          c.response.status = 200; // OK (ignore non-login events)
          return 'Not a login event';
      }
  });

  // === Command Definitions ===
  const cmd = ctx.command(mainCommand, 'Minecraft 绑定相关指令');

  // mc.bind and mc.verify commands are REMOVED in this webhook-triggered flow.

  cmd.subcommand('.code <code:string>', '提交游戏内收到的验证码', { checkArgCount: true })
     .usage(`请提供你在游戏内收到的6位数字验证码。例如：${mainCommand}.code 123456`)
    .action(async ({ session }, code) => {
        if (!session?.userId || !session?.platform || !session?.bot?.selfId) {
             // Should not happen with normal sessions, but safety check
            return '无法获取您的用户信息，请稍后再试。';
        }

        if (!/^\d{6}$/.test(code)) {
            return '验证码格式错误，应为 6 位数字。';
        }

        let pending = undefined as PendingVerification | undefined;
        let mcUsername = undefined as string | undefined;
        let pendingKeyToDelete = undefined as string | undefined; // mcUsername is the key now

        // Find the pending verification entry by CODE
        // Iterate through the pendingVerifications map to find a match
        for (const [userKey, pendingEntry] of pendingVerifications.entries()) {
             if (pendingEntry.verificationCode === code) {
                 pending = pendingEntry;
                 mcUsername = pendingEntry.mcUsername;
                 pendingKeyToDelete = userKey; // Found the key (mcUsername)
                 break; // Found the matching code
             }
        }

        if (!pending || !mcUsername) {
             // No pending entry found for this code
             logger.warn(`[CodeCmd] Incorrect or expired verification code submitted by ${session.platform}:${session.userId}. Code: ${code}`);
            return '验证码错误或已过期，请检查后重试或重新进入服务器获取新的验证码。';
        }

        // === Code matched pending entry, proceed to binding ===
        logger.info(`[CodeCmd] Verification code matched for MC user: ${mcUsername}. User submitting: ${session.platform}:${session.userId}`);

        // Clear the pending state immediately upon successful code match
        clearPending(mcUsername); // Use the key (mcUsername) to delete

        try {
            // 1. Check if the Koishi user is already bound
            const existingBindingByUser = await ctx.database.get('minecraft_bindings', { platform: session.platform, koishiUserId: session.userId });
            if (existingBindingByUser.length > 0) {
                 // This Koishi user is already bound to another MC account
                 logger.warn(`[CodeCmd] Koishi user ${session.platform}:${session.userId} is already bound to ${existingBindingByUser[0].mcUsername}.`);
                 // Re-add the pending state temporarily? No, just inform the user.
                 return `您的QQ账号已经绑定了 Minecraft 账号: ${existingBindingByUser[0].mcUsername}。如需解绑请联系管理员。`;
            }

            // 2. Check if the MC username has been bound by another Koishi user in the meantime
             const existingBindingByMc = await ctx.database.get('minecraft_bindings', { mcUsername });
             if (existingBindingByMc.length > 0) {
                 // This MC account was bound by someone else while the user was entering the code
                 logger.warn(`[CodeCmd] MC user ${mcUsername} was bound by ${existingBindingByMc[0].platform}:${existingBindingByMc[0].koishiUserId}.`);
                 return `Minecraft 账号 ${mcUsername} 在您输入验证码期间已被其他用户绑定。请联系管理员确认。`;
             }

            // 3. If checks pass, save the binding
            await ctx.database.create('minecraft_bindings', {
                platform: session.platform,
                koishiUserId: session.userId,
                mcUsername: mcUsername,
                bindTimestamp: new Date(),
            });

            logger.success(`[CodeCmd] Binding saved: ${session.platform}:${session.userId} <-> ${mcUsername}`);

            // 4. Add player to whitelist (they were likely removed when kicked or aren't added until verified)
            const whitelistAddCmd = `whitelist add ${mcUsername}`;
             try {
                 const whitelistAddResp = await sendRconCommand(config, whitelistAddCmd);
                 logger.info(`[CodeCmd] Added ${mcUsername} to whitelist after successful binding. Response: ${whitelistAddResp}`);
                 // Optional: Check if whitelistAddResp indicates success
             } catch (rconError: any) {
                 logger.error(`[CodeCmd] Failed to add ${mcUsername} to whitelist after successful binding:`, rconError.message);
                 // Binding is saved, but whitelist failed - inform user/admin
                 await session.send(`注意：成功绑定账号 (${mcUsername})，但添加白名单失败 (${rconError.message})。请联系管理员手动添加白名单。`);
                 return; // Exit action, avoid sending success message below
             }

            // 5. Send success message
            return `🎉 绑定成功！您的QQ账号 (${session.username}) 现已绑定到 Minecraft 账号: ${mcUsername}。现在可以进入服务器了。`;

        } catch (dbError: any) {
            logger.error(`[CodeCmd] Database error while saving binding for ${session.platform}:${session.userId}:`, dbError);

             if (dbError.code === 'ER_DUP_ENTRY' || (dbError.message && dbError.message.includes('UNIQUE constraint failed'))) {
                  // This case should theoretically be caught by the checks above, but handling as fallback
                 const existing = await ctx.database.get('minecraft_bindings', { $or: [ { platform: session.platform, koishiUserId: session.userId }, { mcUsername: mcUsername } ]});
                 if(existing.length > 0) {
                     const conflict = existing[0];
                     if (conflict.mcUsername === mcUsername) {
                          return `绑定失败：Minecraft 账号 ${mcUsername} 在您验证期间已被绑定。请联系管理员处理。`;
                     } else {
                         return `绑定失败：您的 Koishi 账号似乎已绑定了其他 MC 账号 (${conflict.mcUsername})。`;
                     }
                 } else {
                     // If DB error indicates duplicate but we couldn't find the record, something is wrong.
                     return '绑定失败：写入数据库时发生唯一性约束错误，但未能定位冲突记录。请联系管理员。';
                 }
             }
             // For other database errors
            return '绑定过程中发生数据库错误，请联系管理员。';
        }
    });

    // Middleware for private message verification (check if it's a 6-digit code)
    // If a 6-digit code is received in private message, simulate the `.code` command action.
      ctx.middleware(async (session, next) => {
        if (session.isDirect && /^\d{6}$/.test(session.content ?? '')) {
            const code = session.content!;
            logger.debug(`[Middleware] Received potential verification code via DM: ${code}`);

            // Find the pending verification entry by CODE
            let pending = undefined as PendingVerification | undefined;
            let mcUsername = undefined as string | undefined;

            for (const [userKey, pendingEntry] of pendingVerifications.entries()) {
                 if (pendingEntry.verificationCode === code) {
                     pending = pendingEntry;
                     mcUsername = pendingEntry.mcUsername;
                     break;
                 }
            }

            if (!pending || !mcUsername) {
                // No matching pending verification, proceed to next middleware
                 // logger.debug(`[Middleware] No pending verification found for code ${code}.`);
                return next();
            }

             // === Code matched pending entry, proceed to binding (similar to .code action) ===
             // Clear pending state immediately
             clearPending(mcUsername);

            logger.info(`[Middleware] Verification code matched for MC user: ${mcUsername} via DM from ${session.platform}:${session.userId}.`);

            try {
                const existingBindingByUser = await ctx.database.get('minecraft_bindings', { platform: session.platform, koishiUserId: session.userId });
                if (existingBindingByUser.length > 0) {
                     logger.warn(`[Middleware] Koishi user ${session.platform}:${session.userId} is already bound to ${existingBindingByUser[0].mcUsername}. (Via DM)`);
                     await session.send(`您的 Koishi 账号已经绑定了 Minecraft 账号: ${existingBindingByUser[0].mcUsername}。如需解绑请联系管理员。`);
                     return; // Message handled
                }

                 const existingBindingByMc = await ctx.database.get('minecraft_bindings', { mcUsername });
                 if (existingBindingByMc.length > 0) {
                     logger.warn(`[Middleware] MC user ${mcUsername} was bound by ${existingBindingByMc[0].platform}:${existingBindingByMc[0].koishiUserId}. (Via DM)`);
                     await session.send(`Minecraft 账号 ${mcUsername}在您输入验证码期间已被其他用户绑定。请联系管理员确认。`);
                     return; // Message handled
                 }

                await ctx.database.create('minecraft_bindings', {
                    platform: session.platform,
                    koishiUserId: session.userId,
                    mcUsername: mcUsername,
                    bindTimestamp: new Date(),
                });

                logger.success(`[Middleware] Binding saved (DM): ${session.platform}:${session.userId} <-> ${mcUsername}`);

                const whitelistAddCmd = `whitelist add ${mcUsername}`;
                 try {
                     const whitelistAddResp = await sendRconCommand(config, whitelistAddCmd);
                     logger.info(`[Middleware] Added ${mcUsername} to whitelist after successful binding (DM). Response: ${whitelistAddResp}`);
                 } catch (rconError: any) {
                     logger.error(`[Middleware] Failed to add ${mcUsername} to whitelist after successful binding (DM):`, rconError.message);
                     await session.send(`注意：成功绑定账号 (${mcUsername})，但添加白名单失败 (${rconError.message})。请联系管理员手动添加白名单。`);
                      return; // Message handled
                 }

                await session.send(`🎉 绑定成功！您的 Koishi 账号 (${session.username}) 现已绑定到 Minecraft 账号: ${mcUsername}。白名单已添加，现在可以进入服务器了。`);
                return; // Message handled

            } catch (dbError: any) {
                logger.error(`[Middleware] Database error saving binding for ${session.platform}:${session.userId} (DM):`, dbError);
                 if (dbError.code === 'ER_DUP_ENTRY' || (dbError.message && dbError.message.includes('UNIQUE constraint failed'))) {
                      const existing = await ctx.database.get('minecraft_bindings', { $or: [ { platform: session.platform, koishiUserId: session.userId }, { mcUsername: mcUsername } ]});
                       if(existing.length > 0) {
                            const conflict = existing[0];
                            if (conflict.mcUsername === mcUsername) {
                                 await session.send(`绑定失败：Minecraft 账号 ${conflict.mcUsername} 在您验证期间已被绑定。请联系管理员处理。`);
                            } else {
                                await session.send(`绑定失败：您的 Koishi 账号似乎已绑定了其他 MC 账号 (${conflict.mcUsername})。`);
                            }
                         } else {
                              await session.send('绑定失败：写入数据库时发生唯一性约束错误，但未能定位冲突记录。请联系管理员。');
                         }
                    return; // Message handled
                 }
                await session.send('绑定过程中发生数据库错误，请联系管理员。');
                return; // Message handled
            }
        }
        // If not a 6-digit private message from a pending user, pass to next middleware
        return next();
    });

     cmd.subcommand('.info', '查看您绑定的 Minecraft 账号')
        .action(async ({ session }) => {
            if (!session?.userId || !session?.platform) {
                return '无法获取用户信息。';
            }
            const binding = await ctx.database.get('minecraft_bindings', { platform: session.platform, koishiUserId: session.userId });
            if (binding.length > 0) {
                return `您 (${session.username}) 已绑定 Minecraft 账号: ${binding[0].mcUsername}`;
            } else {
                return `您尚未绑定 Minecraft 账号。请通过进入 Minecraft 服务器触发绑定流程，然后在 Koishi 中使用 \`${mainCommand}.code <验证码>\` 完成绑定。`;
            }
        });

    // Admin unbind command
    ctx.command(`${mainCommand}.unbind <mcUsername:string>`, '管理员解除绑定 Minecraft 账号', { authority: 3 })
        .action(async ({ session }, mcUsername) => {
             if (!mcUsername) {
                 return '请提供要解除绑定的 Minecraft 用户名。'
             }
             try {
                const result = await ctx.database.remove('minecraft_bindings', { mcUsername });
                // Check for deletedCount
                if (result && typeof result === 'object' && 'deletedCount' in result && (result as any).deletedCount > 0) {
                     logger.info(`[Admin] Removed binding for MC user: ${mcUsername}. (${(result as any).deletedCount} entries)`);
                    // Attempt to remove whitelist (optional, best effort, new connection)
                    try {
                        // Use the config directly as session is not needed for RCON call here
                        const whitelistResponse = await sendRconCommand(config, `whitelist remove ${mcUsername}`);
                         logger.info(`[Admin] Attempted to remove whitelist for ${mcUsername} after unbinding. Response: ${whitelistResponse}`);
                    } catch (rconErr: any) {
                        logger.warn(`[Admin] Failed to remove whitelist for ${mcUsername} after unbinding:`, rconErr.message);
                    }
                    return `已解除 Minecraft 账号 ${mcUsername} 的绑定。`;
                } else {
                    return `未找到与 Minecraft 账号 ${mcUsername} 关联的绑定记录。`;
                }
             } catch (dbError: any) {
                 logger.error(`[Admin] Database error during unbind for ${mcUsername}:`, dbError);
                 return '解除绑定时发生数据库错误，请联系管理员。';
             }
        });
}